package knightwood.kv.aop.floordatastore.ksp

import androidx.datastore.preferences.core.MutablePreferences
import androidx.datastore.preferences.core.Preferences
import com.google.auto.service.AutoService
import com.google.devtools.ksp.isPublic
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LIST
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.STAR
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo
import knightwood.kv.aop.floorcore.annotation.KVStore
import knightwood.kv.aop.floorcore.ksp.writer.IDaoGenerator
import knightwood.kv.aop.floorcore.ksp.writer.KVAnnotationUtils
import knightwood.kv.aop.floordatastore.DataStoreUtils
import knightwood.kv.aop.floordatastore.DatastoreDao
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.lang.StringBuilder

/**
 * 生成如下类结构
 * ```
 * // This file is generated by floor-datastore-ksp
 * // Do not modify it manually
 * //
 * // Generated by floor-datastore-ksp
 * // Generated at 1769212008793
 * //
 * package floor
 *
 * import androidx.datastore.preferences.core.MutablePreferences
 * import androidx.datastore.preferences.core.Preferences
 * import knightwood.kv.aop.floordatastore.DataStoreUtils
 * import knightwood.kv.aop.floordatastore.DatastoreDao
 * import kotlin.Boolean
 * import kotlin.Int
 * import kotlin.String
 * import kotlin.collections.List
 *
 * public open class AppSettingsBean_Dao() : DatastoreDao<AppSettingsBean>("app_settings") {
 *   override val keys: List<Preferences.Key<*>> =
 *       listOf(Keys.isDebug, Keys.name, Keys.fuck_age, Keys.sex, Keys.id)
 *
 *   public override fun Preferences.asT(): AppSettingsBean = AppSettingsBean(
 *           isDebug = this[Keys.isDebug]?:false,
 *           name = this[Keys.name]?:"uui",
 *           age = this[Keys.fuck_age]?:12,
 *           sex = this[Keys.sex]!!,
 *           id = floor.TypeConvertors.string2Uuid(this[Keys.id]!!),
 *   )
 *
 *   public override fun AppSettingsBean.modify(target: MutablePreferences): Preferences = target.apply {
 *        this[Keys.isDebug] = isDebug
 *        this[Keys.name] = name
 *        this[Keys.fuck_age] = age
 *        this[Keys.sex] = sex
 *        this[Keys.id] = floor.TypeConvertors.uuid2String (id)
 *   }
 *
 *   public object Keys {
 *     public val isDebug: Preferences.Key<Boolean> =
 *         DataStoreUtils.getKeyInternal("isDebug",kotlin.Boolean::class)
 *
 *     public val name: Preferences.Key<String> =
 *         DataStoreUtils.getKeyInternal("name",kotlin.String::class)
 *
 *     public val fuck_age: Preferences.Key<Int> =
 *         DataStoreUtils.getKeyInternal("fuck_age",kotlin.Int::class)
 *
 *     public val sex: Preferences.Key<Int> = DataStoreUtils.getKeyInternal("sex",kotlin.Int::class)
 *
 *     public val id: Preferences.Key<String> = DataStoreUtils.getKeyInternal("id",String::class)
 *   }
 * }
 * ```
 *
 * 接下来要用到的词：
 *
 * 数据类：指被@KVStore注解的类，也就是用于映射键值对数据库中某组键值对的类
 * 数据键：指键值对数据库中的某个键，在datastore中是Preference.Key类型，比如：key1 = intPreference("key_name")
 * 数据键名称：指键值对数据库中的某个键的名称，比如上面的"key_name"
 * 数据类字段：指数据键在数据类中映射的变量，其用@KVField注解注释
 * Dao：继承自DatastoreDao类，最终生成的类文件，用于读写键值对数据库，简化datastore使用
 */
@AutoService(IDaoGenerator::class)
open class DatastoreDaoGenerator public constructor() : IDaoGenerator {
    private val logger: Logger = LoggerFactory.getLogger(this::class.java)
    private val dbtype: String = KVStore.DBType.DATASTORE

    private lateinit var codeGenerator: CodeGenerator
    private lateinit var kspLogger: KSPLogger
    private val stringClassName = String::class.asClassName()
    private val preferenceKeyClassName = Preferences.Key::class.asClassName()

    override fun isSupport(dbtype: String): Boolean {
        return dbtype == this.dbtype
    }

    override fun setArg(
        kspLogger: KSPLogger,
        codeGenerator: CodeGenerator,
    ) {

        this.kspLogger = kspLogger
        this.codeGenerator = codeGenerator
    }

    /**
     * 根据@KVStore标记的类，生成dao类
     *
     * @param dbFileName datastore文件名
     * @param daoName 要生成的dao类名
     * @param classDeclaration @KVStore注解标记的数据类
     */
    override fun generateFile(
        outPackage: String,
        dbFileName: String?, daoName: String, classDeclaration: KSClassDeclaration,
    ) {
        //@KVStore注解标记的数据类
        val entity: ClassName = classDeclaration.toClassName()
        runCatching {
            val fileSpec = FileSpec.builder(
                outPackage,
                daoName
            )
                .addFileComment("This file is generated by floor-datastore-ksp\n")
                .addFileComment("Do not modify it manually\n")
                .addFileComment("\n")
                .addFileComment("Generated by floor-datastore-ksp\n")
                .addFileComment("Generated at ${System.currentTimeMillis()}\n")
                .apply {
                    this
                        .addImport(DataStoreUtils::class.asClassName().packageName, "DataStoreUtils")
                        .addType(//生成Dao类
                            TypeSpec
                                .classBuilder(daoName)
                                .addModifiers(KModifier.PUBLIC, KModifier.OPEN)
                                //构造函数留空即可
                                .primaryConstructor(FunSpec.constructorBuilder().build())
                                //继承自DatastoreDao抽象类并指定泛型
                                // KSP 处理过程中，被注解的类（floor.AppSettingsBean）还没有被编译完成，因此无法通过 Class.forName() 加载。
//                                .superclass(DatastoreDao::class.parameterizedBy(Class.forName(entity.reflectionName()).kotlin))
                                //要用下面这种方式才行
                                .superclass(DatastoreDao::class.asClassName().parameterizedBy(entity))
                                //调用父类的构造函数，传参
                                .addSuperclassConstructorParameter("\"${dbFileName}\"")
                                .apply {
                                    //获取public字段，填充类文件
                                    val fields = classDeclaration.getAllProperties().filter { declaration ->
                                        declaration.isPublic()
                                    }.toList()
                                    this.fillClassFile(fields, entity)
                                }.build()
                        )
                }.build()
            fileSpec.writeTo(codeGenerator, false)
        }.onFailure {
            logger.error("generate file error", it)
            throw it
        }
    }

    /**
     * 根据数据类字段上标记的@KVField注解，填充Dao类
     */
    private fun TypeSpec.Builder.fillClassFile(
        ksPropertyDeclaration: List<KSPropertyDeclaration>,
        entityClsName: ClassName,
    ) {
        val builder = this

        // 存储所有数据键名称，用于辅助override val keys: List<Preferences.Key<*>> 生成
        val allDataStoreKeys = mutableListOf<String>()
        //用于辅助生成 asT 方法
        val asTFunction = StringBuilder().append("return ${entityClsName.simpleName}(\n")
        //用于辅助生成modify 方法
        val modifyFunction = StringBuilder().append("return target.apply {\n")


        //构建一个object类，用于存储所有生成的数据键
        val keysObjectSpec = TypeSpec.objectBuilder("Keys")
            .apply {
                val builder = this
                // 遍历所有添加了@KVFiele注解的数据类字段，生成数据键
                ksPropertyDeclaration.forEach { propertyDeclaration ->
                    val annotation = propertyDeclaration.annotations.firstOrNull {
                        it.shortName.asString() == "KVField"
                    }
                    if (annotation != null) {
                        //@KVField注解中记录的数据键名称
                        //最终生成的数据键和数据键名相同
                        //例如：val age: Preferences.Key<Int> = intPreferenceKey("age")
                        //        数据键                                        数据键名
                        val keyName = KVAnnotationUtils.parseKVFieldKeyName(annotation, propertyDeclaration)
                        //该数据键对应的默认值
                        val defaultValueStr = KVAnnotationUtils.parseDefaultValueStr(annotation, propertyDeclaration)

                        //@KVField(defaultValue = "")
                        //val age: Int,
                        //数据类字段的类型
                        val propertyClsName = propertyDeclaration.type.resolve().toClassName()
                        //数据类字段名称
                        val propertyName = propertyDeclaration.simpleName.asString()
                        val isBasicType = TypeSupportUtils.isSupport(propertyClsName)
                        //生成数据键
                        if (isBasicType) {
                            builder.addProperty(
                                PropertySpec
                                    .builder(
                                        keyName,
                                        preferenceKeyClassName.parameterizedBy(propertyClsName),
                                        KModifier.PUBLIC,
                                    )
                                    .mutable(false)
                                    .initializer("DataStoreUtils.getKeyInternal(\"$keyName\",${propertyClsName.reflectionName()}::class)")
                                    .build()
                            )
                            asTFunction.append("        $propertyName = this[Keys.$keyName]$defaultValueStr,\n")
                            modifyFunction.append("     this[Keys.$keyName] = $propertyName\n")
                        } else {
                            builder.addProperty(
                                PropertySpec
                                    .builder(
                                        keyName,
                                        preferenceKeyClassName
                                            .parameterizedBy(stringClassName),
                                        KModifier.PUBLIC,
                                    )
                                    .mutable(false)
                                    .initializer("DataStoreUtils.getKeyInternal(\"$keyName\",String::class)")
                                    .build()
                            )
                            val toFieldFun = TypeSupportUtils.findFunction(
                                stringClassName,
                                propertyClsName
                            ) ?: error("${propertyClsName.simpleName} not support convert")
                            asTFunction.append("        $propertyName = ${toFieldFun.qualifiedName!!.asString()}(this[Keys.$keyName]$defaultValueStr),\n")
                            val toBasicFun = TypeSupportUtils.findFunction(
                                propertyClsName,
                                stringClassName
                            ) ?: error("${propertyClsName.simpleName} not support convert")
                            modifyFunction.append("     this[Keys.$keyName] = ${toBasicFun.qualifiedName!!.asString()} ($propertyName)\n")

                        }
                        allDataStoreKeys.add(keyName)
                    }
                }
            }
            .build()
        builder.addType(keysObjectSpec)

        //实现 override val keys: List<Preferences.Key<*>> = listOf(key_isDebug, key_name, key_age)
        val keysProperty = PropertySpec
            //生成 override val keys: List<Preferences.Key<*>>
            .builder(
                "keys",
                LIST.parameterizedBy(preferenceKeyClassName.parameterizedBy(STAR))
            )
            .addModifiers(KModifier.OVERRIDE)
            .initializer(
                CodeBlock.builder()
                    // 生成 listOf(Keys.isDebug, Keys.name, Keys.age)
                    .add("listOf(%L)", allDataStoreKeys.joinToString(separator = ", ", transform = { "Keys.$it" }))
                    .build()
            )
            .build()
        builder.addProperty(keysProperty)
        asTFunction.append(")")
        modifyFunction.append("}")
        //添加asT方法
        builder.addFunction(
            FunSpec
                .builder("asT")
                .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
                .receiver(Preferences::class)
                .returns(entityClsName)
                .addCode(asTFunction.toString())
                .build()
        )
        //添加modify方法
        builder.addFunction(
            FunSpec
                .builder("modify")
                .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
                .addParameter("target", MutablePreferences::class)
                .receiver(entityClsName)
                .returns(Preferences::class)
                .addCode(modifyFunction.toString())
                .build()
        )
    }
}

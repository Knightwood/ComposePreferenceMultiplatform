package com.knightwood.floor.mmkv.ksp

import com.google.auto.service.AutoService
import com.google.devtools.ksp.isPublic
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LIST
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.STAR
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo
import com.knightwood.floor.core.annotation.KVStore
import com.knightwood.floor.core.ksp.writer.IDaoGenerator
import com.knightwood.floor.core.ksp.writer.KVAnnotationUtils
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.lang.StringBuilder

/**
 * 生成如下类结构
 * ```
 * // This file is generated by floor-MMKV-ksp
 * // Do not modify it manually
 * //
 * // Generated by floor-MMKV-ksp
 * // Generated at 1769233432541
 * //
 * package com.github.knight.composepreference_multi
 *
 * import com.knightwood.floor.mmkv.MMKVDao
 * import com.knightwood.floor.mmkv.MMKVEditor
 * import com.knightwood.floor.mmkv.parseEditor
 * import com.tencent.mmkv.MMKV
 * import kotlin.Int
 * import kotlin.String
 * import kotlin.collections.List
 *
 * public open class MMKVBean_Dao() : MMKVDao<MMKVBean>("") {
 *   override val keys: List<String> = listOf(Keys.name, Keys.age, Keys.id)
 *
 *   public override fun MMKV.asT(): MMKVBean = MMKVBean(
 *           name = Editors.name.read(mmkv, Keys.name)?:"jack",
 *           age = Editors.age.read(mmkv, Keys.age)?:null,
 *           id = floor.TypeConvertors.string2Uuid(Editors.id.read(mmkv, Keys.id)?:"5d14963a-2a32-4e91-ae8b-ab92a865cdc4"),
 *   )
 *
 *   public override fun MMKVBean.modify(target: MMKV) {
 *     target.apply {
 *          Editors.name.write(mmkv, Keys.name, name)
 *          Editors.age.write(mmkv, Keys.age, age)
 *          Editors.id.write(mmkv, Keys.id, floor.TypeConvertors.uuid2String(id))
 *     }
 *   }
 *
 *   public object Keys {
 *     public val name: String = "name"
 *
 *     public val age: String = "age"
 *
 *     public val id: String = "id"
 *   }
 *
 *   public object Editors {
 *     public val name: MMKVEditor<String> = parseEditor(kotlin.String::class)
 *
 *     public val age: MMKVEditor<Int?> = parseEditor(kotlin.Int::class)
 *
 *     public val id: MMKVEditor<String> = parseEditor(kotlin.String::class)
 *   }
 * }
 *
 * ```
 *
 * 接下来要用到的词：
 *
 * 数据类：指被@KVStore注解的类，也就是用于映射键值对数据库中某组键值对的类
 * 数据键：指键值对数据库中的某个键，在MMKV中是Preference.Key类型，比如：key1 = intPreference("key_name")
 * 数据键名称：指键值对数据库中的某个键的名称，比如上面的"key_name"
 * 数据类字段：指数据键在数据类中映射的变量，其用@KVField注解注释
 * Dao：继承自MMKVDao类，最终生成的类文件，用于读写键值对数据库，简化MMKV使用
 */
@AutoService(IDaoGenerator::class)
open class MMKVDaoGenerator public constructor() : IDaoGenerator {
    private val logger: Logger = LoggerFactory.getLogger(this::class.java)
    private val dbtype: String = KVStore.DBType.MMKV

    private lateinit var codeGenerator: CodeGenerator
    private lateinit var kspLogger: KSPLogger
    private val stringClassName = String::class.asClassName()
    private val preferenceKeyClassName = String::class.asClassName()
    private val mmkvClassName = ClassName("com.tencent.mmkv", "MMKV")
    private val editorClsName = ClassName("com.knightwood.floor.mmkv", "MMKVEditor")

    override fun isSupport(dbtype: String): Boolean {
        return dbtype == this.dbtype
    }

    override fun setArg(
        kspLogger: KSPLogger,
        codeGenerator: CodeGenerator,
    ) {

        this.kspLogger = kspLogger
        this.codeGenerator = codeGenerator
    }

    /**
     * 根据@KVStore标记的类，生成dao类
     *
     * @param dbFileName MMKV文件名
     * @param daoName 要生成的dao类名
     * @param classDeclaration @KVStore注解标记的数据类
     */
    override fun generateFile(
        outPackage: String,
        dbFileName: String?, daoName: String, classDeclaration: KSClassDeclaration,
    ) {
        //@KVStore注解标记的数据类
        val entity: ClassName = classDeclaration.toClassName()
        runCatching {
            val fileSpec = FileSpec.builder(
                outPackage,
                daoName
            )
                .addFileComment("This file is generated by floor-MMKV-ksp\n")
                .addFileComment("Do not modify it manually\n")
                .addFileComment("\n")
                .addFileComment("Generated by floor-MMKV-ksp\n")
                .addFileComment("Generated at ${System.currentTimeMillis()}\n")
                .apply {
                    this
                        .addImport(editorClsName.packageName,editorClsName.simpleName)
                        .addImport("com.knightwood.floor.mmkv","MMKVEditors")
                        .addType(//生成Dao类
                            TypeSpec
                                .classBuilder(daoName)
                                .addModifiers(KModifier.PUBLIC, KModifier.OPEN)
                                //构造函数留空即可
                                .primaryConstructor(FunSpec.constructorBuilder().build())
                                //继承自MMKVDao抽象类并指定泛型
                                // KSP 处理过程中，被注解的类（floor.AppSettingsBean）还没有被编译完成，因此无法通过 Class.forName() 加载。
//                                .superclass(MMKVDao::class.parameterizedBy(Class.forName(entity.reflectionName()).kotlin))
                                //要用下面这种方式才行
                                .superclass(ClassName("com.knightwood.floor.mmkv", "MMKVDao").parameterizedBy(entity))
                                //调用父类的构造函数，传参
                                .addSuperclassConstructorParameter("\"${dbFileName}\"")
                                .apply {
                                    //获取public字段，填充类文件
                                    val fields = classDeclaration.getAllProperties().filter { declaration ->
                                        declaration.isPublic()
                                    }.toList()
                                    this.fillClassFile(fields, entity)
                                }.build()
                        )
                }.build()
            fileSpec.writeTo(codeGenerator, false)
        }.onFailure {
            logger.error("generate file error", it)
            throw it
        }
    }

    /**
     * 根据数据类字段上标记的@KVField注解，填充Dao类
     */
    private fun TypeSpec.Builder.fillClassFile(
        ksPropertyDeclaration: List<KSPropertyDeclaration>,
        entityClsName: ClassName,
    ) {
        val builder = this

        // 存储所有数据键名称，用于辅助override val keys: List<Preferences.Key<*>> 生成
        val allMMKVKeys = mutableListOf<String>()
        //用于辅助生成 asT 方法
        val asTFunction = StringBuilder().append("return ${entityClsName.simpleName}(\n")
        //用于辅助生成modify 方法
        val modifyFunction = StringBuilder().append("target.apply {\n")

        //构建一个object类，用于存储所有生成的数据键编辑器
        val editorsObjectBuilder = TypeSpec.objectBuilder("Editors")

        //构建一个object类，用于存储所有生成的数据键
        val keysObjectSpec = TypeSpec.objectBuilder("Keys")
            .apply {
                val builder = this
                // 遍历所有添加了@KVFiele注解的数据类字段，生成数据键
                ksPropertyDeclaration.forEach { propertyDeclaration ->
                    val annotation = propertyDeclaration.annotations.firstOrNull {
                        it.shortName.asString() == "KVField"
                    }
                    if (annotation != null) {
                        //@KVField注解中记录的数据键名称
                        //最终生成的数据键和数据键名相同
                        //例如：val age: String  = "age"
                        //        数据键          数据键名
                        val keyName = KVAnnotationUtils.parseKVFieldKeyName(annotation, propertyDeclaration)
                        //该数据键对应的默认值
                        val defaultValueStr = KVAnnotationUtils.parseDefaultValueStr(annotation, propertyDeclaration)

                        //@KVField(defaultValue = "")
                        //val age: Int,
                        //数据类字段的类型
                        val propertyClsName = propertyDeclaration.type.resolve().toClassName()
                        //数据类字段名称
                        val propertyName = propertyDeclaration.simpleName.asString()
                        val isBasicType = TypeSupportUtils.isSupport(propertyClsName)
                        //生成数据键
                        builder.addProperty(
                            PropertySpec
                                .builder(keyName, preferenceKeyClassName, KModifier.PUBLIC)
                                .mutable(false)
                                .initializer("\"$keyName\"")
                                .build()
                        )
                        if (isBasicType) {
                            // val id :Editor<Int> = parseEditor(Int::class.java)
                            editorsObjectBuilder.addProperty(
                                PropertySpec
                                    .builder(keyName, editorClsName.parameterizedBy(propertyClsName), KModifier.PUBLIC)
                                    .mutable(false)
                                    .initializer("MMKVEditors.parseEditor<$propertyClsName>()")
                                    .build()
                            )
                            asTFunction.append("        $propertyName = Editors.$keyName.read(mmkv, Keys.$keyName)$defaultValueStr,\n")
                            modifyFunction.append("     Editors.$keyName.write(mmkv, Keys.$keyName, $propertyName)\n")
                        } else {

                            // val id :Editor<String> = parseEditor(String::class.java)
                            editorsObjectBuilder.addProperty(
                                PropertySpec
                                    .builder(keyName, editorClsName.parameterizedBy(stringClassName), KModifier.PUBLIC)
                                    .mutable(false)
                                    .initializer("MMKVEditors.parseEditor<String>()")
                                    .build()
                            )

                            // id = floor.TypeConvertors.string2Uuid(Editors.id.read(mmkv, Keys.id)?:"5d14963a-2a32-4e91-ae8b-ab92a865cdc4")
                            val toFieldFun = TypeSupportUtils.findFunction(
                                stringClassName,
                                propertyClsName
                            ) ?: error("${propertyClsName.simpleName} not support convert")
                            asTFunction.append("        $propertyName = ${toFieldFun.qualifiedName!!.asString()}(Editors.$keyName.read(mmkv, Keys.$keyName)$defaultValueStr),\n")

                            //Editors.id.write(mmkv, Keys.id, floor.TypeConvertors.uuid2String(id))
                            val toBasicFun = TypeSupportUtils.findFunction(
                                propertyClsName,
                                stringClassName
                            ) ?: error("${propertyClsName.simpleName} not support convert")
                            modifyFunction.append("     Editors.$keyName.write(mmkv, Keys.$keyName, ${toBasicFun.qualifiedName!!.asString()}($propertyName))\n")
                        }
                        allMMKVKeys.add(keyName)
                    }
                }
            }
            .build()
        builder.addType(keysObjectSpec)
        builder.addType(editorsObjectBuilder.build())

        //实现 override val keys: List<String> = listOf(key_isDebug, key_name, key_age)
        val keysProperty = PropertySpec
            //生成 override val keys: List<String>
            .builder(
                "keys",
                LIST.parameterizedBy(preferenceKeyClassName)
            )
            .addModifiers(KModifier.OVERRIDE)
            .initializer(
                CodeBlock.builder()
                    // 生成 listOf(Keys.isDebug, Keys.name, Keys.age)
                    .add("listOf(%L)", allMMKVKeys.joinToString(separator = ", ", transform = { "Keys.$it" }))
                    .build()
            )
            .build()
        builder.addProperty(keysProperty)
        asTFunction.append(")")
        modifyFunction.append("}")
        //添加asT方法
        builder.addFunction(
            FunSpec
                .builder("asT")
                .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
                .receiver(mmkvClassName)
                .returns(entityClsName)
                .addCode(asTFunction.toString())
                .build()
        )
        //添加modify方法
        builder.addFunction(
            FunSpec
                .builder("modify")
                .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
                .addParameter("target", mmkvClassName)
                .receiver(entityClsName)
                .addCode(modifyFunction.toString())
                .build()
        )
    }
}
